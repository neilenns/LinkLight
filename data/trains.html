<!doctype html>
<html class="wa-dark wa-cloak" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>LinkLight - Train Status</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css"
    />
    <link rel="stylesheet" href="global.css" />
    <script
      src="https://kit.webawesome.com/2ef289f478d44f55.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <script src="/notyf.js" defer></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      body {
        display: flex;
        flex-direction: column;
        padding: 20px;
        box-sizing: border-box;
        gap: 10px;
      }
      .led-grid {
        background-color: var(--wa-color-surface-raised);
        border: var(--wa-border-style) var(--wa-border-width-s)
          var(--wa-color-surface-border);
        border-radius: var(--wa-border-radius-m);
        padding: 8px;
        margin: 0 0 10px 0;
        flex-shrink: 0;
        overflow-x: auto;
      }
      .led-row {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        gap: 6px;
        white-space: nowrap;
      }
      .led-row:last-child {
        margin-bottom: 0;
      }
      .led-row-label {
        width: 150px;
        min-width: 150px;
        font-size: var(--wa-font-size-s);
        color: var(--wa-color-text-quiet);
      }
      .leds-container {
        display: flex;
        gap: 2px;
      }
      .led-square {
        width: 10px;
        height: 10px;
        border-radius: 2px;
        background-color: var(--wa-color-neutral-20);
        flex-shrink: 0;
      }
      .led-square.has-trains {
        cursor: pointer;
        outline: 1px solid var(--wa-color-surface-border);
      }
      .led-square.line-1 {
        background-color: var(--ll-sound-transit-green);
      }
      .led-square.line-2 {
        background-color: var(--ll-sound-transit-blue);
      }
      .led-square.shared-track {
        background-color: var(--ll-shared-track);
      }

      /* Train table styles*/
      .table-container {
        flex: 1;
        overflow-y: auto;
        min-height: 0;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: var(--wa-font-size-m);
        table-layout: fixed;
      }
      thead {
        position: sticky;
        background-color: var(--wa-color-surface-raised);
        font-size: var(--wa-font-size-m);
        z-index: 1;
      }
      th {
        padding: 10px 12px;
        text-align: left;
        color: var(--ll-sound-transit-blue);
        border-bottom: 2px solid var(--wa-color-surface-border);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      td {
        padding: 8px 12px;
        border-bottom: 1px solid var(--wa-color-surface-border);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      tr:hover td {
        background-color: color-mix(
          in oklab,
          var(--wa-color-brand-fill-normal),
          var(--wa-color-mix-hover)
        );
      }
      tr.focused-train td {
        background-color: color-mix(
          in oklab,
          var(--wa-color-brand-fill-normal),
          var(--wa-color-mix-active)
        );
      }
      tbody tr {
        cursor: pointer;
      }
      td.state-at-station {
        color: var(--wa-color-green-80);
        font-weight: var(--wa-font-weight-semibold);
      }
      td.state-moving {
        color: var(--wa-color-cyan-80);
      }
      td.line-1 {
        color: var(--ll-sound-transit-green);
        font-weight: var(--wa-font-weight-semibold);
      }
      td.line-2 {
        color: var(--ll-sound-transit-blue);
        font-weight: var(--wa-font-weight-semibold);
      }
      td.no-trains {
        color: var(--wa-color-text-quiet);
        text-align: center;
        padding: 40px;
      }
      .last-updated {
        color: var(--wa-color-text-quiet);
        font-size: var(--wa-font-size-s);
        margin-left: auto;
      }

      /* LED hover popup */
      .led-popup {
        position: fixed;
        inset: auto;
        margin: 0;
        padding: 0;
        border: none;
        background: transparent;
        z-index: 100;
        max-width: 280px;
        cursor: text;
      }
      .led-popup:not(:popover-open) {
        display: none;
      }
      .train-card {
        background-color: #2d2d30;
        border: 1px solid #3c3c3c;
        border-radius: 4px;
        padding: 8px 10px;
        margin-bottom: 6px;
        font-size: 12px;
        line-height: 1.5;
      }
      .train-card:last-child {
        margin-bottom: 0;
      }
      .train-card-header {
        font-weight: bold;
        margin-bottom: 4px;
      }
      .train-card-header.line-1 {
        color: #4ec9b0;
      }
      .train-card-header.line-2 {
        color: #569cd6;
      }
      .train-card-row {
        color: #9cdcfe;
      }
      .train-card-state-at {
        color: #4ec9b0;
      }
      .train-card-state-moving {
        color: #9cdcfe;
      }
    </style>
  </head>
  <body>
    <h1>LinkLight - Train Status</h1>

    <div class="controls">
      <wa-button id="pauseButton" size="small">Pause</wa-button>
      <wa-badge id="connectionStatus" variant="neutral" appearance="filled" pill
        >Connecting...</wa-badge
      >
      <wa-badge
        id="focusIndicator"
        class="focus-indicator"
        variant="brand"
        appearance="filled"
        style="display: none"
        pill
      ></wa-badge>
      <span class="last-updated" id="lastUpdated"></span>
    </div>

    <div class="led-grid" id="ledGrid">
      <div class="led-row">
        <span class="led-row-label">Line 2 northbound</span>
        <div class="leds-container" id="leds-Line 2 northbound"></div>
      </div>
      <div class="led-row">
        <span class="led-row-label">Line 2 southbound</span>
        <div class="leds-container" id="leds-Line 2 southbound"></div>
      </div>
      <div class="led-row">
        <span class="led-row-label">Line 1 northbound</span>
        <div class="leds-container" id="leds-Line 1 northbound"></div>
      </div>
      <div class="led-row">
        <span class="led-row-label">Line 1 southbound</span>
        <div class="leds-container" id="leds-Line 1 southbound"></div>
      </div>
    </div>

    <div class="led-popup" id="ledPopup" popover="manual"></div>

    <div class="table-container">
      <table id="trainTable">
        <colgroup>
          <col style="width: 11%" />
          <col style="width: 10%" />
          <col style="width: 23%" />
          <col style="width: 10%" />
          <col style="width: 23%" />
          <col style="width: 23%" />
        </colgroup>
        <thead>
          <tr>
            <th>Vehicle ID</th>
            <th>Line</th>
            <th>Headsign</th>
            <th>State</th>
            <th>Closest stop</th>
            <th>Next stop</th>
          </tr>
        </thead>
        <tbody id="trainTableBody">
          <tr>
            <td colspan="6" class="no-trains">Waiting for train data...</td>
          </tr>
        </tbody>
      </table>
    </div>

    <script>
      let isPaused = false;
      let pendingTrains = null;
      let pendingLEDs = null;
      let ws = null;
      let reconnectTimer = null;
      let wsPort = 81;
      let trainLookup = {};
      let lastTrains = null;
      let focusedVehicleId = "";

      // Takes seconds and converts it to a pretty display format.
      // stateClass is included to override the time in case the train is still slightly away from the station but is already
      // considered "At Station" based on the threshold.
      function prettyTime(seconds, stateClass) {
        const isPast = seconds < 0;
        const abs = Math.abs(seconds);

        let out;
        if (abs <= 0 || stateClass === "state-at-station") {
          return "now";
        } else if (abs < 5) {
          return "soon";
        } else {
          const m = Math.floor(abs / 60);
          const s = abs % 60;

          if (m > 0 && s > 0) out = `${m}m ${s}s`;
          else if (m > 0) out = `${m}m`;
          else out = `${s}s`;
        }

        return isPast ? `${out} ago` : `in ${out}`;
      }

      function togglePause() {
        isPaused = !isPaused;
        const button = document.getElementById("pauseButton");

        if (isPaused) {
          button.textContent = "Resume";
        } else {
          button.textContent = "Pause";
          if (pendingTrains !== null) {
            renderTrains(pendingTrains);
            pendingTrains = null;
          }
          if (pendingLEDs !== null) {
            renderLEDs(pendingLEDs);
            pendingLEDs = null;
          }
        }
      }

      // Given a list of train IDs, determine the appropriate CSS class for the corresponding LED square based on which lines the trains belong to.
      function getClassFromTrainIds(trainIds) {
        let hasLine1 = false;
        let hasLine2 = false;
        for (const id of trainIds) {
          const train = trainLookup[id];
          if (!train) continue;
          if (train.line === 1) hasLine1 = true;
          if (train.line === 2) hasLine2 = true;
        }
        if (hasLine1 && hasLine2) return "shared-track";
        if (hasLine1) return "line-1";
        if (hasLine2) return "line-2";
        return "no-trains";
      }

      function renderLEDs(ledsData) {
        if (!ledsData.rows) return;

        ledsData.rows.forEach(function (row) {
          const container = document.getElementById(`leds-${row.label}`);
          if (!container) return;

          // Build a sparse map of physicalLEDIndex â†’ trainIds from the non-empty LEDs in the message.
          const ledMap = {};
          if (row.leds) {
            row.leds.forEach(function (led) {
              ledMap[led.index] = led.trainIds;
            });
          }

          // Render count squares. Compute the physical LED index for each position using the
          // row's start index and direction, then look it up in the map. Absent = off.
          let html = "";
          const step = row.descending ? -1 : 1;
          for (let pos = 0; pos < row.count; pos++) {
            const ledIndex = row.start + pos * step;
            const ids = ledMap[ledIndex] || [];
            const squareClass = getClassFromTrainIds(ids);
            const hasTrains = ids.length > 0;

            html += `<div class="led-square ${hasTrains ? "has-trains" : ""} ${squareClass}" id="led-${ledIndex}"`;
            if (hasTrains) {
              html += ` data-ids="${escapeHtml(ids.join(","))}"`;
            }
            html += "></div>";
          }
          container.innerHTML = html;
        });
      }

      function renderTrains(trains) {
        lastTrains = trains;
        const tbody = document.getElementById("trainTableBody");

        // Update train lookup used by the LED grid popup and colour computation
        trainLookup = {};
        if (trains) {
          trains.forEach(function (t) {
            trainLookup[t.vehicleId] = t;
          });
        }

        if (!trains || trains.length === 0) {
          tbody.innerHTML =
            '<tr><td colspan="6" class="no-trains">No trains found.</td></tr>';
          return;
        }

        let html = "";
        trains.forEach(function (train) {
          const stateClass =
            train.state === "At Station" ? "state-at-station" : "state-moving";
          const lineClass = train.line === 1 ? "line-1" : "line-2";
          const focusedClass =
            train.vehicleId === focusedVehicleId ? " focused-train" : "";

          html += `<tr data-vehicle-id="${escapeHtml(train.vehicleId)}" class="${focusedClass.trim()}">`;
          html += `<td>${escapeHtml(train.vehicleId)}</td>`;
          html += `<td class="${lineClass}">Line ${train.line}</td>`;
          html += `<td>${escapeHtml(train.headsign)}</td>`;
          html += `<td class="${stateClass}">${escapeHtml(train.state)}</td>`;
          html += `<td>${escapeHtml(train.closestStop)}, ${prettyTime(train.closestStopTimeOffset, stateClass)}</td>`;
          html += `<td>${escapeHtml(train.nextStop)}, ${prettyTime(train.nextStopTimeOffset, stateClass)}</td>`;
          html += "</tr>";
        });

        tbody.innerHTML = html;

        const now = new Date();
        document.getElementById("lastUpdated").textContent =
          `Last updated: ${now.toLocaleTimeString()}`;
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function updateConnectionStatus(connected) {
        const badge = document.getElementById("connectionStatus");
        if (connected) {
          badge.textContent = "Connected";
          badge.variant = "success";
        } else {
          badge.textContent = "Disconnected";
          badge.variant = "danger";
        }
      }

      // LED hover popup (native dialog)
      const ledGrid = document.getElementById("ledGrid");
      const ledPopup = document.getElementById("ledPopup");
      let popupHideTimer = null;

      function clearPopupHideTimer() {
        if (popupHideTimer) {
          clearTimeout(popupHideTimer);
          popupHideTimer = null;
        }
      }

      function schedulePopupHide() {
        clearPopupHideTimer();
        popupHideTimer = setTimeout(function () {
          if (ledPopup.matches(":popover-open")) {
            ledPopup.hidePopover();
          }
        }, 120);
      }

      function buildPopupHtml(ids) {
        let html = "";
        ids.forEach(function (id) {
          const train = trainLookup[id];
          if (!train) return;
          const headerClass = train.line === 1 ? "line-1" : "line-2";
          const stateClass =
            train.state === "At Station"
              ? "train-card-state-at"
              : "train-card-state-moving";
          html += '<div class="train-card">';
          html += `<div class="train-card-header ${headerClass}">Vehicle ${escapeHtml(train.vehicleId)} &mdash; Line ${train.line}</div>`;
          html += `<div class="train-card-row">To: ${escapeHtml(train.headsign)}</div>`;
          html += `<div class="${stateClass}">${escapeHtml(train.state)}</div>`;
          html += `<div class="train-card-row">Closest: ${escapeHtml(train.closestStop)}, ${prettyTime(train.closestStopTimeOffset)}</div>`;
          html += `<div class="train-card-row">Next: ${escapeHtml(train.nextStop)}, ${prettyTime(train.nextStopTimeOffset)}</div>`;
          html += "</div>";
        });
        return html;
      }

      function positionPopup(square) {
        const rect = square.getBoundingClientRect();
        let x = rect.left;
        let y = rect.bottom + 4;

        ledPopup.style.left = `${x}px`;
        ledPopup.style.top = `${y}px`;

        const popupRect = ledPopup.getBoundingClientRect();
        if (popupRect.right > window.innerWidth) {
          x = window.innerWidth - popupRect.width - 4;
          ledPopup.style.left = `${x}px`;
        }
        if (popupRect.bottom > window.innerHeight) {
          y = rect.top - popupRect.height - 4;
          ledPopup.style.top = `${y}px`;
        }
      }

      function showPopupForSquare(square) {
        const ids = square.dataset.ids ? square.dataset.ids.split(",") : [];
        if (!ids.length) return;

        const html = buildPopupHtml(ids);
        if (!html) return;

        ledPopup.innerHTML = html;
        if (!ledPopup.matches(":popover-open")) {
          ledPopup.showPopover();
        }
        positionPopup(square);
      }

      ledGrid.addEventListener("pointerover", function (e) {
        const square = e.target.closest(".led-square.has-trains");
        if (!square) return;
        clearPopupHideTimer();
        showPopupForSquare(square);
      });

      ledGrid.addEventListener("pointerout", function (e) {
        const square = e.target.closest(".led-square.has-trains");
        if (!square) return;

        if (
          e.relatedTarget &&
          (e.relatedTarget.closest(".led-square.has-trains") ||
            e.relatedTarget.closest("#ledPopup"))
        ) {
          return;
        }
        schedulePopupHide();
      });

      ledPopup.addEventListener("pointerenter", function () {
        clearPopupHideTimer();
      });

      ledPopup.addEventListener("pointerleave", function (e) {
        if (
          e.relatedTarget &&
          e.relatedTarget.closest(".led-square.has-trains")
        ) {
          return;
        }
        schedulePopupHide();
      });

      document.addEventListener("pointerdown", function (e) {
        if (!ledPopup.matches(":popover-open")) return;
        if (
          e.target.closest("#ledPopup") ||
          e.target.closest(".led-square.has-trains")
        ) {
          return;
        }
        ledPopup.hidePopover();
      });

      document
        .getElementById("trainTableBody")
        .addEventListener("click", function (e) {
          const row = e.target.closest("tr[data-vehicle-id]");
          if (!row) return;
          setFocus(row.dataset.vehicleId);
        });

      function setFocus(vehicleId) {
        focusedVehicleId = focusedVehicleId === vehicleId ? "" : vehicleId;

        const indicator = document.getElementById("focusIndicator");
        if (focusedVehicleId) {
          indicator.textContent = `Focused: ${focusedVehicleId}`;
          indicator.style.display = "inline-flex";
        } else {
          indicator.textContent = "";
          indicator.style.display = "none";
        }

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({ type: "setFocus", vehicleId: focusedVehicleId }),
          );
        }

        if (lastTrains !== null) {
          renderTrains(lastTrains);
        }
      }

      function connectWebSocket() {
        const host = window.location.hostname;
        ws = new WebSocket(`ws://${host}:${wsPort}`);

        ws.onopen = function () {
          updateConnectionStatus(true);
          if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
          }
        };

        ws.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "trains") {
              if (isPaused) {
                pendingTrains = data.trains;
              } else {
                renderTrains(data.trains);
              }
            } else if (data.type === "leds") {
              if (isPaused) {
                pendingLEDs = data;
              } else {
                renderLEDs(data);
              }
            }
          } catch (e) {
            console.error("Error parsing WebSocket message:", e);
          }
        };

        ws.onerror = function (error) {
          console.error("WebSocket error:", error);
        };

        ws.onclose = function () {
          updateConnectionStatus(false);
          reconnectTimer = setTimeout(function () {
            connectWebSocket();
          }, 3000);
        };
      }

      connectWebSocket();

      document
        .getElementById("pauseButton")
        .addEventListener("click", togglePause);
    </script>
  </body>
</html>
